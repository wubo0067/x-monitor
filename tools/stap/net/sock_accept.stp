#!/usr/bin/env stap

/*
功能说明：
1：统计套接字全连接队列长度，全连接队列最大长度，半链接队列长度
2：可按pid过滤
3：每秒输出process accept的次数
*/

%{
#include <linux/version.h>
#include <net/sock.h>
#include <net/tcp.h>
#include <net/ip.h>
#include <linux/skbuff.h>
#include <linux/socket.h>
%}


global filter_pid = 0
//global filter_comm = ""
global filter_family = 2 // AF_INET
global accept_count_map

probe begin {
    print ("Sock Accept Tracing... Hit Ctrl-C to end.\n")
    printf("%s, input argc:%d\n", ctime(), $#)
    if($# == 1) {
        filter_pid = $1
    }
    // } else if ($# == 2) {
    //     filter_pid = $1
    //     filter_comm = @2
    // }
    printf("%s, filter_pid:%d\n", ctime(), filter_pid)
}

probe end {
    print ("Sock Accept Complete\n")
}

/* return the TCP destination port for a given sock */
function __tcp_sock_dport:long (sock:long)
{
  port = @choose_defined(@inet_sock_cast(sock)->sk->__sk_common->skc_dport, # kernel >= 3.8
          @choose_defined(@inet_sock_cast(sock)->inet_dport, # kernel >= 2.6.33
           @choose_defined(@inet_sock_cast(sock)->dport, # kernel >= 2.6.11
                           @inet_sock_cast(sock)->inet->dport)))
  return ntohs(port)
}

/*

inet_csk_accept 是 Linux 内核中用于处理 TCP 连接的函数。它主要用于从已经完成三次握手的队列中取出一个连接控制块（control block），并返回给调用者
 ✘ ⚡ root@localhost  /home/calmwu/Program/x-monitor/tools/stap/net  stap -L 'kernel.function("inet_csk_accept")'
kernel.function("inet_csk_accept@net/ipv4/inet_connection_sock.c:455") $sk:struct sock* $flags:int $err:int* $kern:bool

 ✘ ⚡ root@localhost  /home/calmwu/Program/x-monitor/tools/stap/net  sysctl -a|grep soma
net.core.somaxconn = 128

net.ipv4.tcp_max_syn_backlog = 512
*/
probe kernel.function("inet_csk_accept").return {
    // 套接字，stap中dereference使用->
    cur_pid = pid()
    sock = @entry($sk)
    family  = __ip_sock_family(sock)
    saddr = format_ipaddr(__ip_sock_saddr(sock), family)
    daddr = format_ipaddr(__ip_sock_daddr(sock), family)
    sport = __tcp_sock_sport(sock)
    dport = __tcp_sock_dport(sock)
    bl_len = @cast(@entry($sk), "struct sock")->sk_ack_backlog
    bl_max = @cast(@entry($sk), "struct sock")->sk_max_ack_backlog
    reqsk_queue_len = @cast(@entry($sk), "struct inet_connection_sock")->icsk_accept_queue->qlen->counter
    //inet_family = @cast(@entry($sk), "struct sock")->__sk_common->skc_family
    if(family == filter_family) {
        if(filter_pid != 0) {
            if(filter_pid == cur_pid) {
                accept_count_map[cur_pid, execname()]++
                printf("%s, pid:%d, execname:%s, family:%d, source:(%s:%d), dest:(%s:%d), bl:(%d/%d), rskq_len:(%d)\n", ctime(), cur_pid, execname(), family, saddr, sport, daddr, dport, bl_len, bl_max, reqsk_queue_len)
            }
        } else {
            accept_count_map[cur_pid, execname()]++
            printf("%s, pid:%d, execname:%s, family:%d, source:(%s:%d), dest:(%s:%d), bl:(%d/%d), rskq_len:(%d)\n", ctime(), cur_pid, execname(), family, saddr, sport, daddr, dport, bl_len, bl_max, reqsk_queue_len)
        }
    }

    //print_backtrace()
}

probe timer.s(3) {
    printf("%s\n>>>>>>\n", ctime())
    foreach([pid, execname] in accept_count_map) {
        printf("\tpid:%d, execname:%s, accept_count:%d\n", pid, execname, accept_count_map[pid, execname])
    }
    printf("<<<<<<\n")
    delete accept_count_map
}